import { readdirSync, readFileSync, writeFileSync, watch } from 'fs';
import { join } from 'path';

let lastGenerated = '';

// Build tiers: 'core' (default), 'extended' (includes experimental components)
// Set via BUILD_TIER env var: BUILD_TIER=extended npm run build
const BUILD_TIER = process.env.BUILD_TIER || 'core';

/**
 * Scan src/components/ directory and discover all component files
 */
function discoverComponents() {
	const componentsDir = 'src/components';
	const entries = readdirSync(componentsDir, { withFileTypes: true });
	const components = [];

	for (const entry of entries) {
		if (!entry.isDirectory()) continue;

		const dirPath = join(componentsDir, entry.name);
		const files = readdirSync(dirPath);

		// Find .ts files (excluding styles.ts and settingsStyles.ts)
		for (const file of files) {
			if (!file.endsWith('.ts') || file.includes('styles.ts') || file.includes('Styles.ts')) continue;

			const filePath = join(dirPath, file);
			const content = readFileSync(filePath, 'utf-8');

			// Extract the exported component name
			const match = content.match(/export\s+const\s+(\w+)\s*:\s*Component/);
			if (match) {
				const exportName = match[1];
				const importPath = `${entry.name}/${file.replace('.ts', '')}`;

				// Check enabled: true | false | 'extended'
				const enabledMatch = content.match(/enabled\s*:\s*(true|false|'extended'|"extended")/);
				let tier = 'core'; // default
				if (enabledMatch) {
					const val = enabledMatch[1];
					if (val === 'false') tier = 'disabled';
					else if (val.includes('extended')) tier = 'extended';
				}

				components.push({
					exportName,
					importPath,
					dirName: entry.name,
					fileName: file,
					tier
				});
			}
		}
	}

	return components.sort((a, b) => a.exportName.localeCompare(b.exportName));
}

export function generateRegisterFile() {
	const components = discoverComponents();

	// Filter based on tier:
	// - 'core' build: only core components
	// - 'extended' build: core + extended components
	const enabledComponents = components.filter(c => {
		if (c.tier === 'disabled') return false;
		if (c.tier === 'extended') return BUILD_TIER === 'extended';
		return true; // core components always included
	});

	const imports = enabledComponents.map(c =>
		`import { ${c.exportName} } from "components/${c.importPath}";`
	).join('\n');

	const componentsArray = `export const COMPONENTS: Component<readonly string[]>[] = [\n\t${
		enabledComponents.map(c => c.exportName).join(',\n\t')
	}\n];`;

	const fileContent = `// AUTO-GENERATED FILE - DO NOT EDIT
// This file is automatically generated by scripts/auto-register-plugin.mjs
// To add/remove components, create/delete files in src/components/
// To disable a component, set enabled: false in the component definition
// Build tier: ${BUILD_TIER}

import { Component } from "./components";

${imports}

${componentsArray}
`;

	// Only write if content changed
	if (fileContent !== lastGenerated) {
		lastGenerated = fileContent;
		writeFileSync('src/components.register.ts', fileContent);
		console.log(`[auto-register] Build tier: ${BUILD_TIER}`);
		console.log(`[auto-register] Generated components.register.ts with ${enabledComponents.length} components`);

		const disabled = components.filter(c => c.tier === 'disabled');
		const extended = components.filter(c => c.tier === 'extended');
		if (disabled.length) console.log(`[auto-register] Disabled: ${disabled.map(c => c.exportName).join(', ')}`);
		if (extended.length && BUILD_TIER !== 'extended') {
			console.log(`[auto-register] Extended (not included): ${extended.map(c => c.exportName).join(', ')}`);
		}
		return true;
	}
	return false;
}

/**
 * esbuild plugin to auto-discover and register components
 */
export const autoRegisterComponents = {
	name: 'auto-register-components',
	setup(build) {
		const isWatch = build.initialOptions.watch || process.argv.includes('--watch');

		build.onStart(() => {
			generateRegisterFile();
		});

		// In watch mode, detect new components automatically
		if (isWatch) {
			let debounceTimer = null;

			watch('src/components', { recursive: true }, (eventType, filename) => {
				if (filename && (filename.endsWith('.ts') || eventType === 'rename')) {
					if (debounceTimer) clearTimeout(debounceTimer);
					debounceTimer = setTimeout(() => generateRegisterFile(), 100);
				}
			});
		}
	}
};
